"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5274],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(a),f=r,d=h["".concat(l,".").concat(f)]||h[f]||u[f]||i;return a?n.createElement(d,o(o({ref:t},p),{},{components:a})):n.createElement(d,o({ref:t},p))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8475:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:1},o="Fundamentals of serialization",s={unversionedId:"Getting started/Fundamentals_of_serialization",id:"Getting started/Fundamentals_of_serialization",title:"Fundamentals of serialization",description:"A quick overview of the topic of serializing C# objects, on a purely conceptual level. You are likely familiar with most this already. If you just want to get to the tutorials, feel free to skip this section.",source:"@site/docs/Getting started/Fundamentals_of_serialization.md",sourceDirName:"Getting started",slug:"/Getting started/Fundamentals_of_serialization",permalink:"/persyst-docs/Getting started/Fundamentals_of_serialization",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/persyst-docs/category/getting-started"},next:{title:"Installation",permalink:"/persyst-docs/Getting started/Installation"}},l={},c=[{value:"Serialization, the concept",id:"serialization-the-concept",level:2},{value:"C#",id:"c",level:2},{value:"Value and reference types",id:"value-and-reference-types",level:3},{value:"Serializing values vs serializing references",id:"serializing-values-vs-serializing-references",level:2}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fundamentals-of-serialization"},"Fundamentals of serialization"),(0,r.kt)("p",null,"A quick overview of the topic of serializing C# objects, on a purely conceptual level. You are likely familiar with most this already. If you just want to get to the tutorials, feel free to skip this section. "),(0,r.kt)("h2",{id:"serialization-the-concept"},"Serialization, the concept"),(0,r.kt)("p",null,"Serializing is just getting data into a format that can be stored. In the context that concerns us right now, that means taking the state of your application at runtime, and generating from it a file that can sit on your computer's hard drive. That file must contain all necessary information for us to then turn it back into the original data (",(0,r.kt)("em",{parentName:"p"},"deserialize")," it)."),(0,r.kt)("h2",{id:"c"},"C#"),(0,r.kt)("p",null,"C# is an object-oriented language, so much so that ",(0,r.kt)("em",{parentName:"p"},"all")," the code you write is always part of a class (or a struct, but structs are just ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-gb/dotnet/csharp/language-reference/builtin-types/value-types"},"value-type")," classes). Therefore, serializing C# code is serializing classes."),(0,r.kt)("p",null,"Now, if we ignore ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static"},"static")," members for the moment (or, y'know, altogether; because they are currently not supported by Persyst), that means that what we are serializing is just a set of objects, where an object is just an instance of a class. Those objects can contain ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields"},"Fields")," and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties"},"Properties"),", which are information that is specific to that object. That's the stuff we want to serialize."),(0,r.kt)("h3",{id:"value-and-reference-types"},"Value and reference types"),(0,r.kt)("p",null,"Fields and Properties have a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/"},"type"),", and depending on the type, they are either ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types"},"values")," or ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types"},"references"),". A value-type variable just contains the information itself. For example, let's take an ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"int i = 3;\n")),(0,r.kt)("p",null,"If you were to look at the actual memory of the computer, you would find that the bit of it that corresponds to the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is just ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),". Pretty straightforward."),(0,r.kt)("p",null,"Reference-type variables, on the other hand, don't actually hold the information itself, but rather a... well, a reference to it. That means the information is stored somewhere else, and all the variable contains is the directions on how to find it. This is basically the same concept as ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pointer_(computer_programming)"},"pointers"),", except the conversions between addresses and values all happen implicitly (more convenient to use, and also a bit more opaque to the user, which can be confusing if you are just starting out). For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"public class A{\n    //....\n}\n\nA a = new A();\n")),(0,r.kt)("p",null,"In this case, the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is not the information itself (an instance of the class ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),"), but only a reference to it. You can think of this as an address, or an arrow pointing to it, or whatever you like. A very important implication of this is that, with reference types, you can have multiple variables that all share the same information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"A a = new A();\nA anotherA = a;\n")),(0,r.kt)("p",null,"Now, there is ",(0,r.kt)("strong",{parentName:"p"},"only one")," instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", but we have two references to it. If we use one of the references to modify the object (like ",(0,r.kt)("inlineCode",{parentName:"p"},"a.modify()"),"), accessing the object through the other reference will show the changes as well, because it's the same object. On the contrary, for a value type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"int i = 3;\nint j = i;\n")),(0,r.kt)("p",null,"Now there are two separate values. If you do ",(0,r.kt)("inlineCode",{parentName:"p"},"j=5"),", you are only modifying ",(0,r.kt)("inlineCode",{parentName:"p"},"j"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is still equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),". "),(0,r.kt)("p",null,"When you perform an assignment, you are copying ",(0,r.kt)("strong",{parentName:"p"},"the contents")," of the variable. For a value type, that is the actual value. But for a reference type, that is the reference itself, ",(0,r.kt)("strong",{parentName:"p"},"not the thing that is referenced"),"."),(0,r.kt)("h2",{id:"serializing-values-vs-serializing-references"},"Serializing values vs serializing references"),(0,r.kt)("p",null,"As you can imagine, serializing a value is easier. You just need to come up with a way to represent the value with, say, a string of characters. Just make sure you write down all the information you need, and that's it. "),(0,r.kt)("p",null,"Serializing references is trickier. "),(0,r.kt)("p",null,"Do you store the referenced object's information? Well, you could, but then when you deserialize reference-type variables with equal information, there is no way to tell wether they are references to the same object, or multiple objects that happen to be equal."),(0,r.kt)("p",null,"Do you store the value of the reference variable itself? Nope, that won't work, as the value of the reference will be meaningless when you load it back into a different session, because the object won't be there. Also, this information is not actually available to you as a programmer."),(0,r.kt)("p",null,"What you really want, to preserve references, is some kind of object-ID system that lets you find the referenced object in a way that does not depend on the memory layout of the application. This is one of the more trickier parts of serialization that Persyst can help with."),(0,r.kt)("p",null,"In the next chapters, we will talk about what information can be serialized with Persyst, and wether it is serialized as values or references. Also, for the particularly bold, we will discuss some ways to extend the system so you can ",(0,r.kt)("a",{parentName:"p",href:"/Know_more/Referencing_everything"},"reference anything"),"."))}u.isMDXComponent=!0}}]);